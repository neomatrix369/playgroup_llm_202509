import numpy as np
import pytest

import utils
from run_code import exec_and_run, execute_transform, sanitize_code

CODE_1 = """
def transform(initial):
    # check we receive np.ndarray always
    assert isinstance(initial, np.ndarray), 'Expecting np.ndarray'
    return initial
"""

CODE_2 = """
import numpy as np # confirm double-importing is ok
def transform(initial):
    return initial
"""

# this solves 9565186b, it was mostly generated by a model
CODE_3 = """
def transform(initial):
    import numpy as np
    initial = np.array(initial)
    assert initial.shape == (3,3)

    # Find the frequency of each value in "initial"
    freq_dict = {}
    for i in range(3):
        for j in range(3):
            if initial[i][j] not in freq_dict:
                freq_dict[initial[i][j]] = 1
            else:
                freq_dict[initial[i][j]] += 1

    # Find the most frequent value, least frequent values, and middle-frequency values
    sorted_freq = sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)
    most_frequent_value = sorted_freq[0][0]
    #least_frequent_values = [x[0] for x in sorted_freq[-2:]]
    #middle_frequency_values = [x[0] for x in sorted_freq[1:-2]]

    # Replace the least frequent values with a new value
    #new_value = max(freq_dict) + 1
    new_value = 5
    final = initial.copy()
    for i in range(3):
        for j in range(3):
            if final[i][j] != most_frequent_value:
                final[i][j] = new_value

    assert final.shape == (3,3)
    return final
    """

CODE_3_tolist = """
def transform(initial):
    import numpy as np
    initial = np.array(initial)
    assert initial.shape == (3,3)

    # Find the frequency of each value in "initial"
    freq_dict = {}
    for i in range(3):
        for j in range(3):
            if initial[i][j] not in freq_dict:
                freq_dict[initial[i][j]] = 1
            else:
                freq_dict[initial[i][j]] += 1

    # Find the most frequent value
    sorted_freq = sorted(freq_dict.items(), key=lambda x: x[1], reverse=True)
    most_frequent_value = sorted_freq[0][0]

    # Replace the least frequent values with a new value
    #new_value = max(freq_dict) + 1 # mistake
    new_value = 5
    final = initial.copy()
    for i in range(3):
        for j in range(3):
            if final[i][j] != most_frequent_value:
                final[i][j] = new_value

    assert final.shape == (3,3)
    return final.tolist()
    """


# this solves 9565186b, it was generated by deepseek
CODE_3_deepseek = """
import numpy as np

def transform(initial):
    assert isinstance(initial, np.ndarray)
    
    # Flatten the array to count frequencies
    flat = initial.flatten()
    unique, counts = np.unique(flat, return_counts=True)
    
    # Find the most frequent number(s)
    max_count = np.max(counts)
    most_frequent = unique[counts == max_count]
    
    # Create a mask for numbers that are not most frequent
    mask = ~np.isin(initial, most_frequent)
    
    # Apply the transformation
    final = initial.copy()
    final[mask] = 5
    
    assert isinstance(final, np.ndarray)
    return final

"""

# THIS FIXTURE IS NOT TIED IN
# Generated using Llama Scout to solve 0d3d703e (baseline prompt, no hints)
CODE_4_0d3d703e = """
import numpy as np

def transform(initial):
    assert isinstance(initial, np.ndarray)
    # Define the mapping
    digit_mapping = {
        0: 0, 1: 5, 2: 6, 3: 4, 4: 3,
        5: 1, 6: 2, 7: 7, 8: 9, 9: 8
    }
    
    # Apply the mapping to each element in the grid
    final = np.vectorize(digit_mapping.get)(initial)
    
    assert isinstance(final, np.ndarray)
    return final
"""

# 2024-10 this is a bad direction to go directly, rather than via
# joblib, as this calls exec which populates the namespace!
CODE_BADLY_NAMED_FN = """
def somethingelse():
    pass"""
CODE_WRONG_NOARGS = """
def transform():
    pass"""
CODE_WRONG_TWOARGS = """
def transform(initial, another):
    pass"""
CODE_GOOD_RAISES_EXCEPTION = """
def transform(initial):
    raise Exception("bad")
    pass"""

CODE_GOOD_RETURNS_NON2DARRAY_1DARR = """
def transform(initial):
    return np.array([1, 2, 3])"""

CODE_GOOD_RETURNS_NON2DARRAY_SCALAR = """
def transform(initial):
    return np.float(1)"""


def assert_no_transform_pollution():
    assert "transform" not in dir()
    assert "transform" not in globals()


def test_exec_and_run():
    initial = [[1, 2], [3, 3]]
    code = ""
    assert_no_transform_pollution()
    with pytest.raises(NameError):
        exec_and_run(code, initial)


def test_execute_transform_on_bad_fn():
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]
    assert_no_transform_pollution()

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_BADLY_NAMED_FN, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert "name 'transform' is not defined" in exception_message
    assert len(execution_outcomes) == 0
    # print(exception_message)

    # TODO how to capture the fact that we got a name error which is useful?
    rr, execution_outcomes, exception_message = execute_transform(
        CODE_WRONG_TWOARGS, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert len(execution_outcomes) == 0
    assert "transform() missing 1 required" in exception_message

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_WRONG_NOARGS, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert len(execution_outcomes) == 0
    assert "transform() takes 0 positional" in exception_message

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_GOOD_RAISES_EXCEPTION, problems
    )
    assert rr.code_did_execute is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert len(execution_outcomes) == 0
    assert "<class 'Exception'>" in exception_message


def test_execute_transform():
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]

    rr, execution_outcomes, exception_message = execute_transform(CODE_1, problems)
    print(rr)
    assert rr.code_did_execute is True
    assert len(execution_outcomes) == 4
    # print(execution_outcomes)
    for eo in execution_outcomes:
        assert not eo.was_correct
        assert np.array(eo.initial).shape == (3, 3)

    rr, execution_outcomes, exception_message = execute_transform(CODE_2, problems)
    print(rr)
    assert rr.code_did_execute is True
    assert len(execution_outcomes) == 4


def test_execute_transform2():
    """check we solve this challenge with (mostly llm) code sample"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]

    for code_block in [CODE_3, CODE_3_deepseek]:
        rr, execution_outcomes, exception_message = execute_transform(
            code_block, problems
        )
        print(execution_outcomes)
        print(rr)
        assert rr.code_did_execute is True
        assert rr.code_ran_on_all_inputs is True
        assert rr.transform_ran_and_matched_for_all_inputs is True
        assert rr.transform_ran_and_matched_at_least_once is True
        assert rr.transform_ran_and_matched_score == 4

        # CODE_3 runs and should make a correct output
        for eo in execution_outcomes:
            assert eo.was_correct
            assert np.array(eo.initial).shape == (3, 3)

        # this variant returns tolist not np array, whilst it should
        # run it should also fail to be scored as only ndarray is
        # expected as the returned type
        rr, execution_outcomes, exception_message = execute_transform(
            CODE_3_tolist, problems
        )
        print(rr)
        assert rr.code_did_execute is True
        assert rr.transform_ran_and_matched_score == 0


def test_execute_transform3():
    problem_train_test = utils.get_examples("0d3d703e")
    problems = problem_train_test["train"]

    for code_block in [CODE_4_0d3d703e]:
        rr, execution_outcomes, exception_message = execute_transform(
            code_block, problems
        )
        print(execution_outcomes)
        print(rr)
        assert rr.code_did_execute is True
        assert rr.code_ran_on_all_inputs is True
        assert rr.transform_ran_and_matched_for_all_inputs is True
        assert rr.transform_ran_and_matched_at_least_once is True
        assert rr.transform_ran_and_matched_score == 4


def test_execute_transform_weird_results():
    """check for valid code that returns a non 2d array"""
    problem_train_test = utils.get_examples("9565186b")
    problems = problem_train_test["train"]

    rr, execution_outcomes, exception_message = execute_transform(
        CODE_GOOD_RETURNS_NON2DARRAY_1DARR, problems
    )
    print(execution_outcomes)
    print(rr)
    assert rr.code_did_execute is True
    assert rr.code_ran_on_all_inputs is True
    assert rr.transform_ran_and_matched_for_all_inputs is False
    assert rr.transform_ran_and_matched_at_least_once is False
    assert rr.transform_ran_and_matched_score == 0


def test_sanitize_code_removes_unicode_arrows():
    """Test that Unicode arrow characters are replaced"""
    code = "def transform(x):\n    # x → y\n    return x"
    result = sanitize_code(code)
    assert "→" not in result
    assert "->" in result


def test_sanitize_code_removes_smart_quotes():
    """Test that smart quotes are replaced with regular quotes"""
    # Use actual Unicode smart quote characters
    code = 'def transform(x):\n    s = \u201chello\u201d\n    return x'
    result = sanitize_code(code)
    assert '\u201c' not in result  # Left smart quote removed
    assert '\u201d' not in result  # Right smart quote removed
    assert '"' in result  # Regular quotes present


def test_sanitize_code_handles_empty():
    """Test that empty/None code is handled gracefully"""
    assert sanitize_code("") == ""
    assert sanitize_code(None) is None


def test_sanitize_code_dedents():
    """Test that indented code blocks are dedented"""
    code = "    def transform(x):\n        return x"
    result = sanitize_code(code)
    # After dedent, should start at column 0
    assert result.startswith("def transform")


def test_sanitize_code_preserves_valid_code():
    """Test that valid Python code is not mangled"""
    code = "def transform(x):\n    return x * 2"
    result = sanitize_code(code)
    assert "def transform(x):" in result
    assert "return x * 2" in result
